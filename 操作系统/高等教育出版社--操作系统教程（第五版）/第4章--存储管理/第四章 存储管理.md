## 第四章 存储管理

### 4.1 存储器工作原理

#### 4.1.1 存储器层次

#### 4.1.2 地址转换与存储保护

- 程序编译。源程序经过编译程序或汇编程序的处理生成目标模块（也叫目标代码）。

- 程序链接。程序链接的作用是根据目标模块之间的调用和依赖关系，将主调模块、被调模块以及所用到的库函数装配和链接成一个完整的可装载执行模块。

  - 静态链接
  - 动态链接
  - 运行时链接

- 程序装载。装载程序把可执行程序装入内存的方式有三种：

  - 绝对装载。即模块内中出现的所有地址都是内存绝对地址。
  - 可重定位装载。根据内存当时使用情况，决定将装载代码模块放入内存的物理位置。
  - 动态运行时装载。为提高内存利用率，装入内存的程序可换出到磁盘上，适当时候再换入到内存中。

  -----------------------------------------------------------

  可执行程序逻辑地址转换（绑定）为物理地址的过程称地址重定位、地址映射或地址转换，与上面三种相对应：

  - 静态地址重定位。
  - 动态地址重定位。每当CPU引用内存地址时，由硬件截取此逻辑地址，并在它被发送到内存之前加上重定位寄存器的值，以实现地址转换。
  - 运行时链接地址重定位。

### 4.2 连续存储管理

#### 4.2.1 固定分区存储管理

- 每个分区有单独的作业等待队列
- 所有等待处理的作业排成一个等待队列

------------------------------------

对固定分区采用静态地址重定位，进程运行时使用绝对地址，可由加载程序进行地址越界检查。

#### 4.2.2 可变分区存储管理

- 空闲区表格管理

- 空闲区链表管理

  -----------------------------------------

  常见可变分区分配算法：

  - 最先适应（first fit）分配算法

  该算法顺序查找未分配区表或链表，直到找到第一个能满足长度要求的空闲区为止，分割此分区，一部分分配给作业，另一部分仍为空闲区。

  - 下次适应（next fit）分配算法

  该算法总是从未分配区的上次扫描结束处顺序查找未分配区表或链表，直至找到第一个能满足长度要求的空闲区为止，同样会分割。

  - 最优适应（best fit）分配算法

  该算法扫描整个未分配区表或链表，从空闲区中挑选一个能满足用户进程要求的最小分区进行分配。

  - 最坏适应（worst fit）分配算法

  该算法扫描整个未分配区表或链表，总是挑选一个最大的空闲区分割给作业使用。

  - 快速适应（quick fit）分配算法

  该算法为那些经常用到的长度的空闲区设立单独的空闲区链表。

  ----------------

  对可变分区采用动态地址重定位，进程的程序和数据的地址转换由硬件完成，硬件方面设置两个专用控制寄存器：

  - 基址寄存器存放分配给进程使用的分区的起始地址
  - 限长寄存器存放进程所占用的连续存储空间的长度

#### 4.2.3 内存不足的存储管理技术

- 移动技术
- 对换技术
- 覆盖技术

### 4.3 分页存储管理

#### 4.3.1 分页存储管理基本原理

- 页面。**进程逻辑地址空间**分成大小相等的区，每个区成为页面或页，编号从0往后依次。
- 页框。又称页帧，把**内存物理地址空间**分成大小相等的区，其大小与页面大小相等，编号从0往后依次。
- 逻辑地址。与此对应，分页存储器的逻辑地址由页号和页内位移两部分组成。
- 内存页框表。该表长度取决于内存划分的物理块数，编号可与物理块号一致。
- 页表。在进行内存分配时以页框为单位，进程的信息有多少页，那么把它装入内存时就分配多少页框。虽然进程的逻辑地址划分成编号连续的页面，但被装入内存后的相应页框未必紧邻。<u>那么页面与被分配的页框如何建立联系呢？</u>使用动态地址重定位技术，让程序在执行时动态地进行地址变换，由于程序以页面为单位存储，所以为每个页面设立一个重定位寄存器，这些重定位寄存器的集合称为**页表**。

#### 4.3.2 翻译快表

为了提高运算速度，在硬件中设置相联存储器，用来存放进程最近访问的部分页表项，也称**转换后援缓冲**（Translation Look_aside Buffer）或**翻译快表**。

#### 4.3.3 分页存储空间分配和去配

有两种表示方法：

- 位示图。
- 链表。

#### 4.3.4 分页存储空间页面共享和保护

#### 4.3.5 多级页表

#### 4.3.6 反置页表

### 4.4 分段存储管理

### 4.5 虚拟存储管理

- 先前介绍的存储管理称为实存管理，必须为进程分配足够内存空间，装入其全部信息装入内存后，实际上并非同时使用，于是考虑将物理内存扩展到大容量内存上，把内存空间当作内存的一部分。
- 关于讨论信息不全部装入内存时是否能够正确运行：在1969年，P. Denning、Knuth及Huck等人研究程序执行的局部性原理是，发现程序和数据的访问都有聚集成群的倾向。

#### 4.5.1 请求分页虚拟存储管理

- 操作系统的存储管理依靠低层硬件支持来完成任务，此硬件称为**存储管理部件**（Memory Management Unit，MMU），它提供地址转换和存储保护功能并支持虚存管理和多任务管理。
- MMU由一组集成电路芯片组成，<u>逻辑地址作为输入，物理地址作为输出</u>，直接送达总线，对内存单元进行寻址。

----------------

问：<u>如何发现页面不在内存中呢？页面不在内存中该如何处理？</u>

扩充页表项内容：

- 引用位。在页面被引用（无论是读或写）时设置，其值帮助系统进行页面淘汰
- 修改位。当页面被修改后硬件自动置位，一旦修改位被设置，此页在调出内存时必须先被写回磁盘
- 保护位。限定页面允许的访问权限
- 内存块号。页面对应的页框号，用于地址转换（即逻辑地址对应物理地址）
- 驻留标志位。是用来指出页面是否已装入内存。

------------

问：<u>页面装入策略有哪些？</u>

- 请页式（demand paging）。即产生缺页异常时调入页面。
- 预调式（prepaging）。

问：<u>页面清除策略有哪些？</u>

- 请页式清除。即仅当一页被选中进行替换且其内容被修改过才把它写回磁盘
- 预约式清除。写出的页仍然在内存中，直到页替换算法选中此页从内存中换出

----

问：<u>页面替换策略有哪些？</u>

- 局部替换。算法有
  - 局部最佳页面替换算法
  - 工作集模型和工作集置换算法
  - 模拟工作集替换算法
  - 缺页频率替换算法
- 全局替换。算法有：
  - 最佳页面替换算法
  - 先进先出页面替换算法
  - 最近最少使用页面替换算法
  - 第二次机会页面替换算法
  - 时钟页面替换算法

问：<u>页面分配策略有哪些？</u>

- 固定分配。即在进程生命周期中保持页框树固定不变，只要有一个缺页错误，进程就会有一页被替换
- 可变分配。即在进程生命周期中所分得的页框数可变，当进程运行的某一段缺页率较高，说明目前**局部性**较差，系统可多分页框降低缺页率，反之减少。

<u>固定分配往往和局部替换策略配合使用，可变分配往往和全局替换策略配合使用。</u>

#### 4.5.2 请求段页式虚拟存储管理

<u>总结</u>：段式存储是基于应用程序结构的存储管理技术，有利于模块化程序设计，便于段的扩充、动态链接、共享和保护，但容易产生段之间的碎片，产生浪费；页式存储是基于物理存储器结构的存储管理技术，存储利用率高，便于系统管理，但是不利于存储共享、保护和动态扩充。

### 4.6 Linux虚拟存储管理

#### 4.6.1 物理内存管理

4.6.2 进程虚拟地址空间管理