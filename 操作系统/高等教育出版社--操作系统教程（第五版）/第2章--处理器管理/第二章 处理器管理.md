## 第二章 处理器管理

### 2.1 处理器状态

#### 2.1.1 处理器

- 指令系统和寄存器
- 特权指令和非特权指令
- 内核态和用户态
- 处理器状态及其转换
- 用户栈和核心栈

#### 2.1.2 程序状态字

- 状态标志，使得一条指令的执行结果影响其后指令的运行。
  - OF溢出标志
  - SF符号标志
  - ZF结果为0标志
  - AF辅助进位标志
  - CF进位标志
  - PF奇偶校验标志
  - AC地址对齐标志
- 控制标志
  - DF方向标志，为1时，使得串指令自动减量，即从高地址向低地址处理串操作
  - TF步进标志，为1时，使处理器执行单步操作
  - IF中断允许标志，为1时，允许响应中断，否则关中断
- 系统标志，与进程管理有关
  - IOPLI/O特权标志
  - NT嵌套任务标志
  - RF回复标志，用于保护模式

### 2.2 中断技术

- 中断是指程序执行过程中遇到急需处理的事件时，暂时中止现行程序在CPU上的运行
- 中断可以分成外中断和内中断
  - 外中断又称中断或异步中断，是指来自处理器之外的中断信号，包括时钟中断、键盘中断、宕机中断和外部设备中断
  - 内中断又称异常或同步终端，是指来自处理器内部的中断信号

### 2.3 Linux中断处理

### 2.4 进程及其实现

#### 2.4.1 进程定义和属性

- 引入进程的两个主要目的：
  - 刻画程序的并发性
  - 解决资源的共享性。
- 进程的属性：
  - 动态性。进程是程序在数据集合上的一次执行过程，是动态概念，同时他有生命周期，由创建而产生、由调度而执行、由事件而等待、由撤销而消亡。
  - 共享性。同一程序同时运行于不同数据集合上时构成不同进程，及多个不同进程可执行相同的程序。
  - 独立性。每个进程是操作系统中的一个独立实体。
  - 制约性。进程因共享资源或协同工作产生相互制约关系，造成进程执行速度的不可预测性。
  - 并发性。多个进程的执行在时间上可以重叠，在单处理器系统中可并发执行，在多处理器系统中可并行执行。

#### 2.4.2 进程状态和转换

- 三态模型。
  - 运行running态
  - 就绪ready态
  - 等待wait态
- 七态模型
  - 新建new态
  - 终止exit态
  - 挂起就绪ready suspend态
  - 挂起等待blocked suspend态

#### 2.4.3 进程描述和组成

程序和数据是进程必须的组成部分，两者刻画进程**静态特征**；而数据控制块的数据结构来刻画进程的**动态特性**，如进程状态、占用资源状况、记录调度信息等。

这个合集被称为进程映像（process image）：

- 进程控制块。每个进程捆绑一个，用来存储进程的标志信息、现场信息和控制信息。<u>进程创建时建立进程控制块，进程撤销时回收进程控制块，它与进程一一对应。</u>
- 进程程序块。
- 进程核心栈。每个进程捆绑一个，进程在内核态工作时使用，用来<u>保存</u>中断/异常现场，<u>保存</u>函数调用的参数、局部变量和返回地址
- 进程数据块。是进程的私有地址空间，存放各种私有数据，<u>用户栈也在数据块中开辟</u>，用于在函数调用时存放栈帧、局部变量和返回地址等参数。

实质上，进程在系统中存在及活动除了本身映像外，还需环境支持，如硬件寄存器、程序状态字寄存器、支持动态地址转换的页表和相关的核心数据结构。在操作系统中，进程物理实体和支持进程运行的环境合称**进程上下文（process context）**，进程在其上下文中运行，当系统调度新进程占有处理器时，新老进程随之发生上下文切换。

- 用户级上下文 text\data\shared memory\user stack
- 寄存器上下文 general register\program counter\EFLAGS\ESP
- 系统级上下文task struct\mm_struct\vm_area_struct\pgd\pmd\pte\kernel stack

每个进程有且仅有一个进程控制块，或称进程描述符。

- 标识信息
- 现场信息
- 控制信息

一般来说，把处于同一状态的所有进程的PCB链接在一起的数据结构称进程队列（process queue)，简称队列。

- 链接方式
- 索引方式

#### 2.4.4 进程上下文切换与处理器状态转换

- 进程上下文切换
  - 中断和异常是激活操作系统的仅有方式，它暂停当前运行进程的执行，把处理器转换至**内核态**。
  - 内核获得处理器控制权后，如果需要就可以进行进程上下文切换，**进程切换必定在内核态而非用户态发生**
- 进程上下文切换时机
  - 内核中不能立即进行调度和切换的情况有：
    - 内核正在处理中断的过程中
    - 进程运行在内核临界区中
    - 内核处在需要屏蔽中断的原子操作中
  - Linux调度时机分：
    - 主动调度。指调用schedule（）函数来释放CPU引起新一轮调度，通常发生在当前进程状态被改变，如执行了read、write、exit等系统调用，导致**进程终止**、**进程阻塞**。
    - 被动调度。
      - 时钟中断中调用函数scheduler_tick
      - 函数try_to_wake_up将阻塞进程唤醒，把它加入运行队列
      - 执行sched_setscheduler函数、sched_yield、pause等系统调用，都要设置重调度标志
  - 处理器状态转换

#### 2.4.5 进程控制和管理

### 2.5 线程及其实现

### 2.6 Linux进程

### 2.7 处理器调度

- 作业和进程的关系
  - 作业（job）是用户提交给操作系统计算的一个独立任务。
  - 进程是已提交完毕并选中运行的作业的执行实体，也是为完成作业任务向系统**申请和分配资源的基本单位**。