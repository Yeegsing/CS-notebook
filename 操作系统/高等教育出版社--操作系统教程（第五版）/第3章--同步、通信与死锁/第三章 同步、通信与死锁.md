## 第三章 同步、通信与死锁

### 3.1 并发进程

- 并发进程可能是无关的，也可能是交互的。交互的并发进程共享某些变量，一个进程的执行可能会影响其他进程的执行结果。
- 进程的交互：竞争与协作
  - 在独立进程之间同时访问一独占型资源，在极端情况下，被阻塞进程永远得不到访问权。这样会带来两个控制问题，一是**死锁**，一组进程因争夺资源陷入永远等待，二是**饥饿**，程序被无期限地拖延而不能被执行。
  - **进程同步（synchronization）**是指为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的先后次序而等待、传递信号或消息所产生的协作制约关系。

### 3.2 临界区管理

- 并发进程中与共享变量有关的程序段被称为**临界区（critical section）**。共享变量所代表的资源称为**临界资源（critical resource）**。

- 实现临界区管理的方法可以分为两种：

  - 软件算法：**Peterson算法**。利用对turn的赋值和while语句来限制每次最多只有一个进程进入临界区。
  - 硬件设施：单处理器计算机系统中并发进程不会同时执行，只会交替地执行，<u>为了保证互斥性，仅需保证进程不被中断</u>。
    - 关中断。在进程进入临界区时关中断，进程退出临界区时开中断。（<u>因为需要有中断事件才会引起进程上下文的切换</u>）
    - 测试并设置指令。
      - 使用硬件所提供的TS机器指令，可以把这条指令看作函数。把变量s看作为一把锁，初值设置为true，表示没有进程在临界区内。
      - 在进入临界区之前，先用TS指令测试s，如果没有进程在临界区内则可以进入，**否则**必须循环测试直至s值位true，**而且**进程在退出临界区时，把s值置为true
    - 对换指令。先把锁设置为false，表示没有进程在临界区内，然后设一个key，该值为true，进来时把lock互换为true，表示有进程在临界区，也叫上锁。

  ### 3.3 信号量与PV操作

  - 信号量与PV操作。先前的软件算法太过复杂，效率低下；而硬件方法虽然简单有效，却使用了忙式等待，白白浪费了CPU的时间。

    - 一般信号量。
      - P：将信号量value值减1，若结果小于0，则执行P操作的进程被阻塞，排入list队列；如果结果大于等于0，执行P操作的程序继续执行。
      - V：将信号量value值加1，若结果不大于0，则执行V操作的进程从队列中释放一个进程，自己则继续执行；如果结果大于0，则执行V操作的进程继续执行。
    - 二值信号量。

  - 哲学家就餐问题。

    ```c++
    /*信号量解决哲学家就餐问题*/
    semaphore fork[5];
    for(int i = 0; i < 5; i++)
        fork[i] = 1;
    cobegin
        process philosopher_i(){
        while(true){
            think();
            P(fork[i]);
            P(fork[(i + 1) % 5]);
            	eat();
            V(fork[i]);
            V(fork[(i + 1) % 5]);
        }
    }
    coend
    ```

  - 生产者-消费者问题。

    

  - 读者-写者问题。

  - 睡眠理发师问题。

### 3.4 管程

- 使用信号量和PV操作实现进程同步时，对共享资源的管理分散于各个进程中，他们能够直接对共享变量进行操作，**但是不利于**系统对临界资源的管理。
- 代表共享资源的数据结构及并发进程在其上执行的一组过程就构成管程。

#### 3.4.1 管程的实现

- 互斥信号量mutex
- 挂起发出signal操作的进程的信号量next和计数器next_count
- 挂起等待资源的进程的信号量x_sem和计数器x_count

### 3.5 进程通信

#### 3.5.1 信号通信方式

- 外中断与内中断（或称中断与异常）被称为硬中断，因为都是通过硬件设施来产生中断请求。而信号是一种软中断机制，信号的发送者相当于中断源（或是内核、进程），而信号的接收者必然是一个进程（相当于CPU）。
- Linux系统中设计了中断处理程序top half和bottom half部分，包括在v2.4版后引入的tasklet、softirq机制等，都被称作为软中断
- 中断机制与信号机制进行类比

#### 3.5.2 管道通信机制

- 管道（pipeline）是UNIX的传统进程通信方式。

#### 3.5.3 共享内存通信机制

- 共享内存是指两个或多个进程共同拥有一块内存区，该区中的内容可被进程访问。

#### 3.5.4 消息传递通信机制

### 3.6 操作系统并发问题解决方案小结

### 3.7 死锁

- 产生原因有很多，比如两个进程分别等待对方所占有的一个资源。会由于进程推进顺序不当、PV操作使用不妥、同类资源分配不均或对某些资源的使用未加限制。是一种无限期陷入僵持的局面

#### 3.7.1 死锁防止

1971年，Coffman总结系统产生死锁的4个必要条件。

- 互斥条件
- 占有和等待条件
- 不剥夺条件
- 循环等待条件

#### 3.7.2 死锁避免

3.7.3 死锁检测和恢复