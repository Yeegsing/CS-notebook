## 第三章 同步、通信与死锁

### 3.1 并发进程

- 并发进程可能是无关的，也可能是交互的。交互的并发进程共享某些变量，一个进程的执行可能会影响其他进程的执行结果。
- 进程的交互：竞争与协作
  - 在独立进程之间同时访问一独占型资源，在极端情况下，被阻塞进程永远得不到访问权。这样会带来两个控制问题，一是**死锁**，一组进程因争夺资源陷入永远等待，二是**饥饿**，程序被无期限地拖延而不能被执行。
  - **进程同步（synchronization）**是指为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的先后次序而等待、传递信号或消息所产生的协作制约关系。

### 3.2 临界区管理

- 并发进程中与共享变量有关的程序段被称为**临界区（critical section）**。共享变量所代表的资源称为**临界资源（critical resource）**。

- 实现临界区管理的方法可以分为两种：

  - 软件算法：**Peterson算法**。利用对turn的赋值和while语句来限制每次最多只有一个进程进入临界区。
  - 硬件设施：单处理器计算机系统中并发进程不会同时执行，只会交替地执行，<u>为了保证互斥性，仅需保证进程不被中断</u>。
    - 关中断。在进程进入临界区时关中断，进程退出临界区时开中断。（<u>因为需要有中断事件才会引起进程上下文的切换</u>）
    - 测试并设置指令。
      - 使用硬件所提供的TS机器指令，可以把这条指令看作函数。把变量s看作为一把锁，初值设置为true，表示没有进程在临界区内。
      - 在进入临界区之前，先用TS指令测试s，如果没有进程在临界区内则可以进入，**否则**必须循环测试直至s值位true，**而且**进程在退出临界区时，把s值置为true
    - 对换指令。先把锁设置为false，表示没有进程在临界区内，然后设一个key，该值为true，进来时把lock互换为true，表示有进程在临界区，也叫上锁。

  ### 3.3 信号量与PV操作

  - 信号量与PV操作。先前的软件算法太过复杂，效率低下；而硬件方法虽然简单有效，却使用了忙式等待，白白浪费了CPU的时间。

    - 一般信号量。
      - P：将信号量value值减1，若结果小于0，则执行P操作的进程被阻塞，排入list队列；如果结果大于等于0，执行P操作的程序继续执行。
      - V：将信号量value值加1，若结果不大于0，则执行V操作的进程从队列中释放一个进程，自己则继续执行；如果结果大于0，则执行V操作的进程继续执行。
    - 二值信号量。

  - 哲学家就餐问题。

    ```c++
    /*信号量解决哲学家就餐问题*/
    semaphore fork[5];
    for(int i = 0; i < 5; i++)
        fork[i] = 1;
    cobegin
        process philosopher_i(){
        while(true){
            think();
            P(fork[i]);
            P(fork[(i + 1) % 5]);
            	eat();
            V(fork[i]);
            V(fork[(i + 1) % 5]);
        }
    }
    coend
    ```

  - 生产者-消费者问题。

    

  - 读者-写者问题。

  - 睡眠理发师问题。