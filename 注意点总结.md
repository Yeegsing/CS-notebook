## 注意点总结

### 4.21

内存分配方式有三种

- 从静态存储区域分配。例如全局变量、static变量。
- 在栈上创建。栈上存放的是
- 从堆上分配。也称动态内存分配。

### 4.23

结构体的初始化

- 可以选择先定义一个例如叫做studentInfo stu的结构体变量，在对其中的值进行赋值。（其实这时候是使用了缺省的构造函数studentInfo(){})

- 重构构造函数

  ```cpp
  struct studentInfo{
      int id;
      char gender;
      studentInfo(int _id, char _gender) {
          //注意上面的形参需要区别一下
          id = _id;
          gender = _gender;
      }
  };
  ```

  ```c++
  struct studentInfo{
      int id;
      char gender;
      studentInfo(int _id, char _gender): id(_id), gender(_gender) {}
  }；
  ```


---

引言模板template

下面是一段双向链表中对等于号的重载

```cpp
Iterator& operator=(Node<T>* pNode)
{
    //Iterator后面的&表明其返回值是一个引用
    this->currNode_ = pNode;
    return *this;
}
```

以及《数据结构》课本上的对向量赋值运算符的重载：

```cpp
template <typename T> Vector<T>& Vector<T>::operator= (Vector<T> const& V) {
    if(_elem) delete []._elem;
    copyFrom(V._elem, 0, V.size());
    return *this;
}
```

---

STL中begin和end定义的是一个左闭右开的区间。

- 判断是否到尾部应该使用！=end，避免使用<运算
- 访问末尾元素，map.end()-1

### 4.24

```c++
transform(s.begin(), s.end(), s.begin(), ::tolower)
```

以上transform是一个函数，最后一个是op操作

---

使用%05d格式输出地址，可以使不足5位的整数的高位补0

### 4.26

使用new来分配内存时，它还会帮助创建了对象

---

### 4.30

handle被称为句柄，可以理解为门的把手，通过门把手就可以拉开门，而不需要关心门的形状，所以说句柄是用来对对象进行操作的标记符